#include <stdint.h>
#include <stddef.h>

// Include our libc compatibility layer
#include "../libc_compat.h"

// Forward declaration of GUI functions
extern void gui_init(int width, int height, void* fb, int pitch);
extern void gui_run();
extern void gui_shutdown();
extern void gui_create_desktop();

// Graphics library declarations - window_t used by gfx.c
typedef struct {
    int x, y;
    int width, height;
    int flags;
    uint32_t bg_color;
    uint32_t border_color;
    const char* title;
} window_t;

// Graphics globals (MUST match gfx.c exactly)
extern uint32_t* framebuffer;
extern int screen_width;
extern int screen_height;
extern int pitch;

// Graphics function declarations
extern void set_pixel(int x, int y, uint32_t color);
extern void fill_rect(int x, int y, int width, int height, uint32_t color);
extern void draw_rect(int x, int y, int width, int height, uint32_t color);
extern void draw_line(int x1, int y1, int x2, int y2, uint32_t color);
extern void draw_char(int x, int y, char c, uint32_t fg, uint32_t bg);
extern void draw_string(int x, int y, const char* str, uint32_t fg, uint32_t bg);
extern void clear_screen(uint32_t color);
extern void draw_wallpaper();

#define COLOR_BLACK     0xFF000000
#define COLOR_WHITE     0xFFFFFFFF
#define COLOR_RED       0xFFFF0000
#define COLOR_GREEN     0xFF00FF00
#define COLOR_BLUE      0xFF0000FF
#define COLOR_GRAY      0xFF808080
#define COLOR_DARK_GRAY 0xFF404040
#define COLOR_LIGHT_GRAY 0xFFC0C0C0
#define COLOR_CYAN      0xFF00FFFF
#define COLOR_YELLOW    0xFFFFFF00
#define COLOR_MAGENTA   0xFFFF00FF

// Simple structure for Multiboot info
typedef struct {
    uint32_t flags;
    uint32_t mem_lower;
    uint32_t mem_upper;
    uint32_t boot_device;
    uint32_t cmdline;
    uint32_t mods_count;
    uint32_t mods_addr;
    uint32_t syms[4];
    uint32_t mmap_length;
    uint32_t mmap_addr;
    uint32_t drives_length;
    uint32_t drives_addr;
    uint32_t config_table;
    uint32_t boot_loader_name;
    uint32_t apm_table;
    uint32_t vbe_control_info;
    uint32_t vbe_mode_info;
    uint16_t vbe_mode;
    uint16_t vbe_interface_seg;
    uint16_t vbe_interface_off;
    uint16_t vbe_interface_len;
} __attribute__((packed)) multiboot_info_t;

// VBE Mode Info Structure
typedef struct {
    uint16_t attributes;
    uint8_t  winA, winB;
    uint16_t granularity;
    uint16_t winsize;
    uint16_t segmentA, segmentB;
    uint32_t realFctPtr;
    uint16_t pitch;
    uint16_t width, height;
    uint8_t  wChar, yChar, planes, bpp, banks;
    uint8_t  memory_model, bank_size, image_pages;
    uint8_t  reserved0;
    uint8_t  red_mask, red_position;
    uint8_t  green_mask, green_position;
    uint8_t  blue_mask, blue_position;
    uint8_t  rsv_mask, rsv_position;
    uint8_t  directcolor_attributes;
    uint32_t physbase;
} __attribute__((packed)) vbe_mode_info_t;

// Port I/O helpers
static inline uint8_t inb(uint16_t port) {
    uint8_t ret;
    __asm__ volatile ("inb %1, %0" : "=a"(ret) : "Nd"(port));
    return ret;
}

static inline void outb(uint16_t port, uint8_t val) {
    __asm__ volatile ("outb %0, %1" : : "a"(val), "Nd"(port));
}

static inline uint16_t inw(uint16_t port) {
    uint16_t ret;
    __asm__ volatile ("inw %1, %0" : "=a"(ret) : "Nd"(port));
    return ret;
}

static inline void outw(uint16_t port, uint16_t val) {
    __asm__ volatile ("outw %0, %1" : : "a"(val), "Nd"(port));
}

// Serial port for debugging
#define SERIAL_PORT 0x3F8

static void serial_init() {
    outb(SERIAL_PORT + 1, 0x00);
    outb(SERIAL_PORT + 3, 0x80);
    outb(SERIAL_PORT + 0, 0x03);
    outb(SERIAL_PORT + 1, 0x00);
    outb(SERIAL_PORT + 3, 0x03);
    outb(SERIAL_PORT + 2, 0xC7);
    outb(SERIAL_PORT + 4, 0x0B);
}

static void serial_putchar(char c) {
    while ((inb(SERIAL_PORT + 5) & 0x20) == 0);
    outb(SERIAL_PORT, c);
}

static void serial_write(const char* s) {
    while (*s) {
        if (*s == '\n') serial_putchar('\r');
        serial_putchar(*s++);
    }
}

static void serial_write_hex(uint32_t v) {
    char buf[12];
    snprintf(buf, sizeof(buf), "0x%X", (unsigned int)v);
    serial_write(buf);
}

static void serial_write_uint(uint32_t v) {
    char buf[12];
    snprintf(buf, sizeof(buf), "%u", (unsigned int)v);
    serial_write(buf);
}

// QEMU/VBox VBE port
#define VBE_DISPI_INDEX_ID 0x1CE
#define VBE_DISPI_DATA 0x1CF

static int vbe_available() {
    outb(VBE_DISPI_INDEX_ID, 0x0);
    uint16_t id = inw(VBE_DISPI_DATA);
    return (id == 0xB0C5 || id == 0xB0C4);
}

static int vbe_set_mode(uint16_t mode) {
    outb(VBE_DISPI_INDEX_ID, 0x02);
    outw(VBE_DISPI_DATA, mode);
    outb(VBE_DISPI_INDEX_ID, 0x01);
    return inw(VBE_DISPI_DATA) == mode;
}

static int vbe_get_mode(uint32_t* w, uint32_t* h, uint32_t* p, uint32_t* addr) {
    outb(VBE_DISPI_INDEX_ID, 0x01);
    uint16_t mode = inw(VBE_DISPI_DATA);
    
    outb(VBE_DISPI_INDEX_ID, 0x02);
    *w = inw(VBE_DISPI_DATA);
    
    outb(VBE_DISPI_INDEX_ID, 0x03);
    *h = inw(VBE_DISPI_DATA);
    
    outb(VBE_DISPI_INDEX_ID, 0x04);
    uint16_t bpp = inw(VBE_DISPI_DATA);
    
    *p = (*w * bpp) / 8;
    
    outb(VBE_DISPI_INDEX_ID, 0x06);
    uint32_t fb_high = inw(VBE_DISPI_DATA);
    outb(VBE_DISPI_INDEX_ID, 0x07);
    uint32_t fb_low = inw(VBE_DISPI_DATA);
    *addr = (fb_high << 16) | fb_low;
    
    if (*addr == 0) *addr = 0xE0000000;
    
    return 1;
}

// VGA text mode
static void vga_write(const char* s, int r, int c, int color) {
    volatile uint16_t* vga = (volatile uint16_t*)0xB8000;
    if (r < 0) r = 0;
    if (r >= 25) r = 24;
    for (int i = 0; s[i] && c + i < 80; i++) {
        vga[r * 80 + c + i] = (uint16_t)s[i] | ((uint16_t)color << 8);
    }
}

static void vga_clear() {
    volatile uint16_t* vga = (volatile uint16_t*)0xB8000;
    for (int i = 0; i < 80 * 25; i++) vga[i] = 0x0A20;
}

void kernel_main(multiboot_info_t* mb_info) {
    heap_init();
    serial_init();
    
    serial_write("\n=== FLUX-OS Kernel ===\n");
    
    vga_clear();
    vga_write("FLUX-OS Starting...", 0, 0, 0x0A);
    
    uint32_t fb_addr = 0;
    uint32_t fb_w = 800;
    uint32_t fb_h = 600;
    uint32_t fb_pitch = 3200;
    int gfx_init = 0;
    
    serial_write("Detecting graphics...\n");
    vga_write("Detecting graphics...", 1, 0, 0x0A);
    
    // Try VBE
    if (vbe_available()) {
        serial_write("VBE detected\n");
        vga_write("VBE detected", 2, 0, 0x0A);
        
        if (vbe_set_mode(0x0118)) {
            vbe_get_mode(&fb_w, &fb_h, &fb_pitch, &fb_addr);
            serial_write("1024x768 mode set\n");
            vga_write("1024x768 mode", 3, 0, 0x0A);
            gfx_init = 1;
        } else if (vbe_set_mode(0x0115)) {
            vbe_get_mode(&fb_w, &fb_h, &fb_pitch, &fb_addr);
            serial_write("800x600 mode set\n");
            vga_write("800x600 mode", 3, 0, 0x0A);
            gfx_init = 1;
        } else if (vbe_set_mode(0x0110)) {
            vbe_get_mode(&fb_w, &fb_h, &fb_pitch, &fb_addr);
            serial_write("640x480 mode set\n");
            vga_write("640x480 mode", 3, 0, 0x0A);
            gfx_init = 1;
        }
    }
    
    // Try multiboot
    if (!gfx_init && mb_info && (mb_info->flags & (1 << 12))) {
        serial_write("Using GRUB fb\n");
        vbe_mode_info_t* vbe = (vbe_mode_info_t*)(uintptr_t)mb_info->vbe_mode_info;
        if (vbe && vbe->physbase) {
            fb_w = vbe->width;
            fb_h = vbe->height;
            fb_pitch = vbe->pitch;
            fb_addr = vbe->physbase;
            gfx_init = 1;
            serial_write("Got fb from GRUB\n");
        }
    }
    
    // Fallback
    if (!gfx_init) {
        serial_write("Using fallback fb\n");
        vga_write("Using fallback", 4, 0, 0x0C);
        fb_addr = 0xE0000000;
        fb_w = 1024;
        fb_h = 768;
        fb_pitch = 4096;
        gfx_init = 1;
    }
    
    // Set globals
    framebuffer = (uint32_t*)(uintptr_t)fb_addr;
    screen_width = (int)fb_w;
    screen_height = (int)fb_h;
    pitch = (int)fb_pitch;
    
    serial_write("FB: ");
    serial_write_hex(fb_addr);
    serial_write(" (");
    serial_write_uint(fb_w);
    serial_write("x");
    serial_write_uint(fb_h);
    serial_write(")\n");
    
    char info[64];
    snprintf(info, sizeof(info), "FB: 0x%X  %dx%d", (unsigned int)fb_addr, (int)fb_w, (int)fb_h);
    vga_write(info, 5, 0, 0x07);
    
    // Clear framebuffer
    serial_write("Clearing fb...\n");
    if (framebuffer) {
        uint32_t* fb = (uint32_t*)(uintptr_t)fb_addr;
        for (uint32_t i = 0; i < fb_w * fb_h; i++) {
            fb[i] = 0xFF1a1a1a;
        }
        serial_write("Fb cleared\n");
        
        // Draw test pattern
        serial_write("Drawing test...\n");
        for (uint32_t y = 0; y < fb_h && y < 100; y++) {
            for (uint32_t x = 0; x < fb_w && x < 100; x++) {
                fb[y * fb_w + x] = 0xFF00FF00;
            }
        }
        serial_write("Test drawn\n");
    }
    
    // Init GUI
    serial_write("Init GUI...\n");
    vga_write("Initializing GUI...", 7, 0, 0x0A);
    
    if (gfx_init && framebuffer) {
        gui_init(screen_width, screen_height, framebuffer, pitch);
        gui_create_desktop();
        
        serial_write("GUI ready, starting loop\n");
        vga_write("GUI Ready!", 8, 0, 0x0A);
        
        gui_run();
    }
    
    vga_write("ERROR: No gfx", 9, 0, 0x0C);
    serial_write("ERROR: No graphics\n");
    
    while (1) __asm__("hlt");
}
